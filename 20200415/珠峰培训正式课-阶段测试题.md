# 珠峰培训正式课-阶段测试题
[TOC]
## 第一部分：以往做过的经典题目
### 1. 下面代码运行的结果？为什么？
```javascript
let res = parseFloat('left:200px');
if(res===200){
   alert(200);
}else if(res===NaN){
   alert(NaN);
}else if(typeof res==='number'){
   alert('number');
}else{
   alert('Invalid Number');
}
```
答 : 弹出 "number", 原因 : `parseFloat` 转换 `'left:200px'` 的结果为`number` 类型的 `NaN`, 而 `NaN` 不等于任何值包括自己。
### 2.下面代码运行的结果？
```javascript
let result = 10+false+undefined+[]+'北京珠峰培训'+null+true+{};
console.log(result);
```
答 : 结果为 : `NaN + '北京珠峰培训' + null + true + {}` => `NaN北京珠峰培训nulltrue[object Object]`
### 3. 下面代码运行的结果？
```javascript
let a = 12;
let b = a;
b = 13;
console.log(a);
-----------------
let a = {n: 12};
let b = a;
b['n'] = 13;
console.log(a.n);
-----------------
let a = {n: 12};
let b = a;
b = {n: 13};
console.log(a.n);
```
答 : 结果为 : `12`、`13`、`12`
### 4. 下面代码运行的结果？
```javascript
let a = {n: 1};
let b = a;
a.x = a = {n: 2};
console.log(a.x);
console.log(b);	
```
答 : `undefined`、`{ n: 1, x: { n: 2 } }`
![image.png](https://upload-images.jianshu.io/upload_images/16761151-0f4189bab3680b08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
### 5. 下面代码运行的结果？
```javascript
let a = typeof typeof typeof [12,23];
console.log(a);
```
答 : `"string"`
### 6. 下面代码运行的结果？
```javascript
var name = 10;
var obj = {
   name: '珠峰培训'
};
console.log(obj.name);
console.log(obj['name']);
console.log(obj[name]);
```
答 : `'珠峰培训'`、`珠峰培训`、`undefined`
### 7. 下面代码运行的结果?
```javascript
var x=5,
    y=6;
function func(){
    x+=y;
    func=function(y){
        console.log(y + (--x));
    };
    console.log(x, y);
}
func(4);
func(3);
console.log(x, y);
```
答 : `11, 6`、`13`、`10, 6`
### 8. 下面代码运行的结果?
```javascript
var x = 4;
function func() {
    return function(y) {
        console.log(y + (--x));
    }
}
var f = func(5);
f(6);
func(7)(8);
f(9);
console.log(x);
```
答 : `9`、`10`、`10`、`1`  
### 9. 下面代码运行的结果？
```javascript
var x = 3,
    obj = {x: 5};
obj.fn = (function () {
    this.x *= ++x;
    return function (y) {
        this.x *= (++x)+y;
        console.log(x);
    }
})();
var fn = obj.fn;
obj.fn(6);
fn(4);
console.log(obj.x, x);
```
分析如下 :<br>
window.x = window.x * (++window.x); => 3 * 4 = > 12<br>
obj.x = obj.x * ((++x) + y); => 5 * (13 + 6) => 95 ; window.x = 13<br>
---> 13<br>
windox.x = window.x * ((++window.x) + 4); => 13 * (14 + 4) => 234; <br>
---> 234<br>
---> 95, 234<br>
答 : `13`、`234`、`95, 234`

### 10. 下面代码运行的结果？
```javascript
var a = 0;
if (true) {
    a = 1;
    function a() {};
    a = 21;
    console.log(a)
}
console.log(a);
```
### 11. 下面代码运行的结果（有难度）？
```javascript
function fun(n, o) {
    console.log(o);
    return {
        fun: function (m) {
            return fun(m, n);
        }
    };
}
var c = fun(0).fun(1);
c.fun(2);
c.fun(3);
```
答 :  `undefined`、`0`、`1`、`1`
![11题草图.png](https://upload-images.jianshu.io/upload_images/16761151-4d02da0048d35fc8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 12. 下面代码a在什么值情况下会输出1？
```javascript
var a = ?;
if (a == 1 && a == 2 && a == 3) {
    console.log(1);
}
```
答 : a 在等于 `{ num: 1, toString() { return this.num++; }, }` 的时候, 该题目会输出 1 。
```javascript
var a = {
	num: 1,
	toString() {
		return this.num++;
	},
};
if (a == 1 && a == 2 && a == 3) {
    console.log(1); // 1
}
```
### 13. 改造下面代码，使之输出0-9
```javascript
for (var i = 0; i < 10; i++) {
    setTimeout(() => {
        console.log(i);
    }, 1000);
}
```
答 : 借助 let 与 闭包都可以解决该问题, 下面是使用闭包解决 : 
```javascript
for (var i = 0; i < 10; i++) {
	(function(i) {
        setTimeout(() => {
            console.log(i);
        }, 1000);
	})(i);
}
```
### 14. 下面代码输出的结果是多少，为什么？如何改造一下，就能让其输出 20 10？
```javascript
var b = 10;
(function b() {
    b = 20;
    console.log(b);
})();
console.log(b);
```
答 : 输出结果为 : `b函数`、`10`。原因 : `b` 函数是只读的, 并且在 b 函数内部对 b 函数所作的所有有关重新赋值的操作都是无效的。所以 `b=20` 这个操作在此题中毫无作用, 既不会更新 b 函数的指向也不会影响到全局中的 b 变量。
### 15. 下面代码运行的结果？
```javascript
let obj = {
    0: 3,
    1: 4,
    length: 0,
    push: Array.prototype.push
}
obj.push(10);
obj.push(20);
console.log(obj);
```
答 : `{ 0: 10, 1: 20, length: 2, push: Array.prototype.push }`
### 16. 下面代码运行的结果？
```javascript
//example 1
let a={}, b='0', c=0;  
a[b]='珠峰';
a[c]='培训';  
console.log(a[b]);
​
---------------------
//example 2
let a={}, b=Symbol('1'), c=Symbol('1');  
a[b]='珠峰';
a[c]='培训';  
console.log(a[b]);
​
---------------------
//example 3
let a={}, b={n:'1'}, c={m:'2'};  
a[b]='珠峰';
a[c]='培训';  
console.log(a[b]);
```
答 : `培训`、`珠峰`、`培训`
### 17. 下面代码运行的结果？
```javascript
function Foo() {
    getName = function () {
        console.log(1);
    };
    return this;
}
Foo.getName = function () {
    console.log(2);
};
Foo.prototype.getName = function () {
    console.log(3);
};
var getName = function () {
    console.log(4);
};
function getName() {
    console.log(5);
}
Foo.getName(); // 2
getName(); // 4
Foo().getName(); // 1
getName(); // 1
new Foo.getName(); // 2
new Foo().getName(); // 3
new new Foo().getName(); // 3
```
答 : `2`、`4`、`1`、`1`、`2`、`3`、`3`
### 18. 下面代码运行的结果？
```javascript
var test = (function(i){
    return function(){
        alert(i*=2);
    }
})(2);
test(5);
```
答 : 弹出 `"4"`
### 19. 实现函数fn，让其具有如下功能
```javascript
let res = fn(1,2)(3);
console.log(res); //=>6  1+2+3
```
答 : 代码实现如下 :
```javascript
function fn(...outerArgs) {
	
	return function(...innerArgs) {
		let arr = [...outerArgs, ...innerArgs].map((item) => Number(item)).filter((item, index) => !isNaN(item));
		return arr.reduce((prev, next) => prev + next, 0);
	};
}
let res = fn(1,2)(3);
console.log(res); //=>6  1+2+3
```
### 20. 下面代码运行的结果？
```javascript
function C1(name) {
    if (name) {
        this.name = name;
    }
}
function C2(name) {
    this.name = name;
}
function C3(name) {
    this.name = name || 'join';
}
C1.prototype.name = 'Tom';
C2.prototype.name = 'Tom';
C3.prototype.name = 'Tom';
alert((new C1().name) + (new C2().name) + (new C3().name));
```
答 :  弹出 `"Tomundefinedjoin"`
### 21. 下面代码运行的结果？
```javascript
function Fn() {
    let a = 1;
    this.a = a;
}
Fn.prototype.say = function () {
    this.a = 2;
}
Fn.prototype = new Fn;
let f1 = new Fn;
​
Fn.prototype.b = function () {
    this.a = 3;
};
console.log(f1.a); // 1
console.log(f1.prototype); // undefined
console.log(f1.b); // b(f)
console.log(f1.hasOwnProperty('b')); // false
console.log('b' in f1); // true
console.log(f1.constructor == Fn); // true
```
答 : `1`、`undefined`、`b(f)`、`false`、`true`、`true`
### 22. 重构内置new方法
```javascript
function Dog(name) {
    this.name = name;
}
Dog.prototype.bark = function () {
    console.log('wangwang');
}
Dog.prototype.sayName = function () {
    console.log('my name is ' + this.name);
}
function _new(...args) {
    //=>完成你的代码
	let instance = Object.create(args[0].prototype, {
		name: {
			enumerable: true,
			value: args[1],
		},
		constructor: {
			enumerable: false,
			value: args[0],
		},
	});
	return instance;
}
let sanmao = _new(Dog, '三毛');
sanmao.bark(); //=>"wangwang"
sanmao.sayName(); //=>"my name is 三毛"
console.log(sanmao instanceof Dog); //=>true
```
### 23. 实现如下需求
```javascript
let n = 10;
let m = n.plus(10).minus(5);
console.log(m);//=>15（10+10-5）
```
答 : 代码实现如下 :
```javascript
function _check(arg) {
	arg = Number(arg);
	return Number.isNaN(arg) ? 0 : arg ;
}
Number.prototype.plus = function plus(arg) {
	return this + _check(arg);
};
Number.prototype.minus = function minus(arg) {
	return this - _check(arg);
};


let n = 10;
let m = n.plus(10).minus(5);
console.log(m);//=>15（10+10-5）
```
### 24. 实现如下需求
```javascript
/*
 * 编写queryURLParams方法实现如下的效果（至少两种方案）
 */
let url="http://www.zhufengpeixun.cn/?lx=1&from=wx#video";
console.log(url.queryURLParams("from")); //=>"wx"
console.log(url.queryURLParams("_HASH")); //=>"video"
```
答 : 代码实现如下 :  
- 方案一 : 【通过字符串方法截取】
```javascript
void((proto) => {
	function queryURLParams(arg) {
		let res = '';
		let str = this.substring(this.indexOf("?") + 1, this.length);
		if(arg === "_HASH") {
			str = str.substring(str.lastIndexOf("#") + 1, str.length);
			res = str;
		}else {
			let splits = str.substring(0, str.lastIndexOf("#")).split("&");
			let arr = splits.filter((item, index) => item.includes(arg));
			if(arr.length !== 0) {
				arr = arr[0].split("=");
				res = arr[1];
			}else {
				res = '';
			}
		}
		return res;
	}
	proto.queryURLParams = queryURLParams;
})(String.prototype);
let url="http://www.zhufengpeixun.cn/?lx=1&from=wx#video";
console.log(url.queryURLParams("from")); //=>"wx"
console.log(url.queryURLParams("_HASH")); //=>"video"
```
- 方案二 : 【正则表达式】
```javascript
void(function(proto) {
	
	function queryURLParams(arg) {
		let obj = {};
		this.replace(/([^#?=&]+)=([^#?=&]+)/g, (_, $1, $2) => obj[$1] = $2);
		this.replace(/#([^#?=&]+)/g, (_, $1) => obj["_HASH"] = $1);
		return obj[arg] || '';
	}
	proto.queryURLParams = queryURLParams;
})(String.prototype);
let url="http://www.zhufengpeixun.cn/?lx=1&from=wx#video";
console.log(url.queryURLParams("from")); //=>"wx"
console.log(url.queryURLParams("_HASH")); //=>"video"
```
### 25. 基于ES6中的class重构下面的代码
```javascript
function Modal(x,y){
    this.x=x;
    this.y=y;
}
Modal.prototype.z=10;
Modal.prototype.getX=function(){
    console.log(this.x);
}
Modal.prototype.getY=function(){
    console.log(this.y);
}
Modal.n=200;
Modal.setNumber=function(n){
    this.n=n;
};
let m = new Model(10,20);
```
答 : 代码实现如下 : 
```javascript
class Modal {
	static n = 200; // 静态属性
	static setNumber() { // 静态方法
		this.n=n;
	}
	constructor(x, y) { 初始化实例属性与实例方法
		this.x = x;
		this.y = y;
	}
	getX() { // 原型方法
		console.log(this.x);
	}
	getY() { // 原型方法
		console.log(this.y);
	}
	get z() { // 原型属性
		return 10
	}
}
let m = new Modal(10,20);
```
## 第二部分：综合练习题
### 1.介绍下 Set、Map、WeakSet 和 WeakMap 的区别？
- Set 与 Map 
	+ Set 是类似于数组的结构, 本身值是有序(这里说的有序指的是添加进数据结构时的顺序而非是自动排序)且唯一 的。
	+ Map 是类似于键值对(Hash) 结构, 本身键是有序(这里说的有序指的是添加进数据结构时的顺序而非是自动排序)且唯一的。
- Set 与 WeakSet
	+ Set 结构内部的成员可以是基本类型值也可以是引用类型值(实现了 iterator 接口的)、但是 WeakSet 内部的成员只能是引用类型值(实现了 iterator 接口的)。
	+ Set 结构内部的变量保存的引用都是强引用, JS 引擎的垃圾回收器在回收的时候会考虑其内部的引用、但是 WeakSet 字如其名 , 内部变量保存的都是弱引用, 也即垃圾回收器在回收时不会考虑其内部的引用。
	+ WeakSet 由于内部的元素项数充满了不确定性, 因而自身没有 size 属性或者 length 属性这样表示长度的。因而也就不能被迭代，仅有部分 Set 结构的方法可以使用, 这包括(add、delete、has)。
- Map 与 WeakMap
	+ Map 结构就是为了弥补 Object 对象只能用基本类型值做键的问题而出现的, 因而 Map 结构的键可以是任意数据类型的, 但是 WeakMap 结构中的键只能是引用类型的。
	+ Map 结构内部的键保存的引用都是强引用, JS 引擎的垃圾回收器在回收的时候会考虑其内部的引用、但是 WeakMap 字如其名 , 结构内部的键保存的都是弱引用, 也即垃圾回收器在回收时不会考虑其内部的引用。
	+ WeakMap 由于内部的键是否存在充满了不确定性, 因而自身没有 size 属性或者 length 属性这样表示长度的。因而也就不能被迭代，仅有部分 Map 结构的方法可以使用, 这包括set、get、delete、has)。
- WeakSet 与 WeakMap
	+ 二者的区别建立在 Set 结构与 Map 结构的基础上。
	+ 二者的联系, 就是内部元素结构充满不确定性, 没有自己的 size / length 属性,因而都不能被迭代, 并且二者内部保存的引用都是弱引用。

### 2. 介绍下 var、let、const 的区别？
- var 有变量提升, let 与 const 没有变量提升。
- 在全局上下文环境中, var 声明的变量会挂载到 window 上, 同时存在于全局变量对象中, 但是 let 与 const 声明的变量不会挂在到 window 上, 仅存在于全局变量对象上。
- 在相同的代码块内, let 声明的变量会在当前代码块形成块级作用域, 并且将自身与当前的块级作用域进行绑定, 而 var 则不会。
- var 可以重复声明, let 不可以重复声明。
- 使用 let 在声明之前使用该变量则会导致暂时性死区问题。
- var 与 let 声明的是变量, const 声明的是常量, 只不过对于引用数据类型值, 不可以改其地址但是可以更改属性。

### 3. `<script>` 放到页面头部和尾部的区别？以及解决办法？
区别 : `<script>` 放到页面的头部和尾部都会阻塞页面的渲染, 但是放到头部会阻塞页面的解析, 放到尾部不会阻塞页面的解析, 这也是为什么放在头部获取 dom 元素会报错的原因。<br>
解决方案 : 
**放在头部 - 通过监听 `window.onload` 事件来延迟脚本到页面解析完毕后再执行**
```html
<html>
	<head>
		<script>
			window.onload = function() {
				// ...
			}
		</script>
	</head>
	<body></body>
</html>
```
**放在头部 - 如果是外链式可使用 defer 属性**
```html
<html>
	<head>
		<script src="./Xxx.js" defer></script>
	</head>
	<body></body>
</html>
```
**将`<script>` 标签放在尾部 **

### 4. 如何基于 ES5/ES6 实现类的继承，两种方式有什么区别？
代码实现 : <br>
**基于 ES5 的继承 :**
```javascript
function Person(name) {
	this.name = name;
}
Person.prototype.sayName = function() {
	console.log(`Hello ${ this.name }`);
};

function Teacher(age, name) {
	this.age = age;
	Person.call(this, name);
}
function extend() {
	let instance = Object.create(Person.prototype, {
		constructor: {
			enumerable: false,
			value: Teacher,
		}
	});
	Teacher.prototype = instance;
}
extend();
Teacher.prototype.sayAge = function() {
	console.log(`Hi ${ this.age }`);
};
let tom = new Teacher(22, "TOM");
console.log(tom.name); // "TOM"
tom.sayName(); // "Hello TOM"
console.log(tom.age); // 22
tom.sayAge(); // "Hi 22"
console.log(tom);
console.log(tom.constructor); //
console.log(Object.getPrototypeOf(tom)); //
```
![image.png](https://upload-images.jianshu.io/upload_images/16761151-c52660c9ec976339.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![image.png](https://upload-images.jianshu.io/upload_images/16761151-1f156256fea5e3ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
**基于 ES6 的继承 :**
```javascript
class Person {
	constructor(name) {
		this.name = name;
	}
	sayName() {
		console.log(`Hello ${ this.name }`);
	}	
}

class Teacher extends Person {
	constructor(age, name) {
		super(name);
		this.age = age;
	}

	sayAge() {
		console.log(`Hi ${ this.age }`);
	}
}
let tom = new Teacher(22, "TOM");
console.log(tom.name); // "TOM"
tom.sayName(); // "Hello TOM"
console.log(tom.age); // 22
tom.sayAge(); // "Hi 22"
console.log(tom);
console.log(tom.constructor); //
console.log(Object.getPrototypeOf(tom)); //
```
![image.png](https://upload-images.jianshu.io/upload_images/16761151-d7234b0829613417.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![image.png](https://upload-images.jianshu.io/upload_images/16761151-19966777e6ff16df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

**区别 :**
- ES5 继承, 最佳的继承方式是通过寄生组合式的方式来实现的继承, 而ES6 中 class 之间的继承是通过 `extends` 关键字来实现的继承。
- ES5 中想要继承父类的私有属性, 实际上是先创建子类的 this , 然后通过 `call` 借用父类的构造函数来初始化自己的 this , 以此来实现父类的私有属性与方法的继承, 而在 ES6 中, 是先通过 `super` 关键字调用父类构造器来创建父类的 this, 一顿初始化后再被子类的构造函数修改了 this以此来实现父类的私有属性与方法的继承。
- ES5 中想要继承父类的公有属性与方法, 必须将自己类的 `prototype` 属性指向一个实例(此实例已经指向了父类的原型)。以此依托原型链来完成公有属性与方法的继承。ES6 中直接通过 extends 关键字即完成了公有属性与方法的继承, class Teacher 的 prototype 的 __proto__ 不再指向 Object, 而是指向了 Person.prototype。
- 写法上 : ES5 的继承写起来颇为麻烦, 定义原型属性与方法都是通过 `Xxx.prototype.Xxx` 的方式, 而从 class 中定义原型属性与方法直接在代码块中写就可以了。ES5 继承中需要自己指定 call/apply 自己修改子类的 prototype 指向, 在ES6 中这些统统不用做, 一个 extends 全搞定。 

### 5. 请说出 “箭头函数和普通函数“ 的区别？
答 : 区别如下 :
- 普通函数 :  
	+ this 永远转向当前函数的调用者。
	+ 支持 arguments 对象
	+ 可以作为构造函数来通过 new 的形式创建当前类的实例。
	+ 可以使用 yield 命令因此可以改造成 generator 函数
- 箭头函数 : 
	+ this 永远指向父级上下文中的 this(`没有自己的 this`、`穿透上下文`),
	+ 不支持 arguments 对象, 但可以通过扩展运算符来接收参数列表来充当 arguments
	+ 因为没有自己的 this 所以不能作为构造函数来通过 new 的形式创建当前类的实例。
	+ 不能使用 yield 命令, 所以不可以改造成 generator 函数

### 6. 请说出你对 “重排和重绘读写分离” 的理解！
- 首先浏览器的渲染机制是, 先将 HTML 页面结构代码 进行解析, 构造一颗 DOM tree , 榆次同时解析样式表代码, 构造一颗 CSSOM tree。然后 DOM tree 与 CSSOM tree 合成 Render tree , 最后渲染到页面上(当然在渲染之前要经历 computed(计算) 、layout(布局) 等操作)。 
- 重排(回流) : 元素样式改变, 但尺寸与位置不变。
- 重绘 : 元素的尺寸与位置发生了变化, 导致浏览器会重走 `computed -> layout -> render` 这个流程。
- 回流一定触发重绘而重绘不一定会回流。

**读写分离 :**
吧设置样式和读取样式的操作分开, 只导致一次回流和重绘。<br>
因为新版本浏览器都有着 `"渲染队列(render queue)"` 的机制, 如果下面紧挨着的还是修改样式的信息的指令, 则会将其添加到 "渲染队列" 中并不会立即执行, 等到全部检查完毕, 再批量的一次性的触发一次回流和重绘。<br>
所以读写分离有利于通过这种机制来减少浏览器回流和重绘的次数并以此来提高页面的渲染效率。

### 7. 请说出你对 “闭包” 的理解！
**概念 :**
学术角度 : 每一个函数执行都会形成一个闭包。
实用角度 : 只有函数内部的引用类型值被外界引用, 该函数的执行上下文长期不能被销毁, 才形成闭包。

**作用 :**
- 保护 : 
形成闭包后, 外界无法直接访问函数内部的变量, 仅限于函数自身访问。
- 保存 : 
形成闭包后, 函数的上下文一直不能销毁, 其活动对象也没有被销毁, 此时外界就可以利用这个机制来访问到函数内部的变量值。

### 8. 请说出你对 “面向对象” 的理解！
- js 中没有类 C 语言中的类的概念, 实际上日常所说的 js 中的类都不是真正的类, 这也包括 ES6 的 class【只不过是ES5构造函数的语法糖】, js 中的 "类" 实际上就是一个构造函数。
- js 中应用面向对象的思维, 可以将过程式的代码更好的进行聚合, 减少代码冗余, 提高复用、性能。
- js 中的一切皆是对象(包括基本类型值都有自己的包装类型) : 并且都有着自己的原型链 :  
	-  每一个对象都有一个 __proto__ 属性指向自己所属 "类" 的原型。
	-  每一个构造函数都有一个 prototype 属性指向自己的原型。
	-  每一个构造函数的原型都有一个 constructor 属性指向自身。
	-  在 js 中 Function 与 Object 的关系就是鸡与蛋蛋与鸡的关系。

- js 中的继承是通过原型链来实现的(原型链有个查找机制), ES5 中最佳的继承方式是 `寄生组合式继承`, ES6 中最佳的继承方式是 `class 的 extends 关键字` 继承。 
	
- 每创建一个引用类型变量, 都会在堆内存中开辟一块空间来存储。

### 9. 下面代码的输出结果？为什么？
```javascript
let arr = [1, 2, 3, 4];
arr = arr.map(parseInt);
console.log(arr);
```
答 : 下面结果输出 `[1, NaN, NaN, NaN]`<br>
原因如下 : <br>
`做这道题首先要弄明白两个点 : map 和 parseInt`<br>
- map 用法 :
具体用法不诉了, 都知道的玩意, 主要说一下, map 中的回调函数每轮迭代会接收两个参数 : `callback(item, index, array)【array 是当前被迭代的数组】`、`thisArg【函数 callback 时用到的 this】`
一个例子 :
```javascript
void(() => {
	let _this = { name: "FruitJ" };
    let arr = [1, 2, 3];
    arr = arr.map((item, index, array) => {
		console.log(array);
		return `item: ${ item };index: ${ index };this.name: ${ _this.name }`;
	}, _this);
	console.log(arr);
})();
```
![image.png](https://upload-images.jianshu.io/upload_images/16761151-686e8d24e1a44af4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
在回调函数中会接收 3 个参数 (item、index、array)。

- parseInt 用法 :  
	+ parseInt 的用法是将字符串参数在转化为数值, 如果 1 参不是字符串参数默认也会转换为字符串参数后再转换为数值, parseInt 还有第二个参数, 第二个参数就是表示当前 1 参的进制位, 譬如说 `parseInt('A', 16); // 10` 这表示了 parseInt 在进行转型之前, 先确定自己要转的元素是一个 16 进制的 A, 所以转换完毕后就转换成了 10 进制的 10, 利用这个特性和 toString 的 2 参结合起来可以做一个任意进制相互转换的 utils 函数。 
	+ 但是这个 parseInt 的 2 参也是有讲究的 :
	 -1). 2 参的范围是 `2 ~ 36` 表示可以表示  2 进制到 36 进制<br>
	 -2). 2参数不传或者传0再或者传递 undefined 遵循以下规则 : 
		 + 如果 parseInt 遇到了不属于radix参数所指定的基数中的字符那么该字符和其后的字符都将被忽略。接着返回已经解析的整数部分。parseInt 将截取整数部分
		 + 如果字符串 string 以"0x"或者"0X"开头, 则基数是16 (16进制).
		 + 如果字符串 string 以"0"开头, 基数是8（八进制）或者10（十进制），那么具体是哪个基数由实现环境决定。ECMAScript 5 规定使用10
		 + 如果字符串 string 以其它任何值开头，则基数是10 (十进制)。

代码验证 :		 
```javascript
void(() => {
	console.log(parseInt('A')); // NaN
	console.log(parseInt('A', 16)); // 10
	console.log(parseInt('0xF')); // 15
	console.log(parseInt('0xF', 0)); // 15
	console.log(parseInt('0xF', undefined)); // 15
	console.log(parseInt('1', 1)); // NaN
})();
```
所以这道题就好解释了 : 
**第一步 : 先看看 parseInt 这个函数设没设置形参**
![image.png](https://upload-images.jianshu.io/upload_images/16761151-b2c181fb4cd7d5b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
很明显, parseInt 没有设置形参, 内部应该是用的 arguments 来做的。

**第二步 : 借一段代码来了解 map -> parseInt 的时候都接收了啥 ?** 
```javascript
void(() => {

	function parseInt() {
		console.log(arguments);
		return "测试中随便返回点什么东西 ...";
	}

	let arr = [1, 2, 3, 4, 5, 6];
	arr.map(parseInt);
})();
```
![image.png](https://upload-images.jianshu.io/upload_images/16761151-7114e113656c1833.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
自定义的 parseInt 函数里面的 arguments 接收到的 参数分别是 map 传递的 item, index和 array。 <br>
到这一步明白这些就成功一半了。<br>
那就说明这道题的 `parseInt` 函数接收到的参数跟我们模拟的是一样的。<br>
所以可以分解为这几步 : <br>
map (item, index) -> 【parseInt(item, index)】<br>
也即 : <br>
map (1, 0) -> 【parseInt(1, 0)】上述 parseInt 进制转换规则提到过, 如果 2 参为 0 , 则默认返回截取到的整数部分, 那 1 就是 1 返回 1  => 1<br>
map (2, 1) -> 【parseInt(2, 1)】上述 parseInt 进制转换规则提到过, 2参范围是 2 ~ 36, 所以 1 不再此范围, 1 参的那个 1 也无法正常转换为数值,就反回了 NaN => NaN<br>
map (3, 2) -> 【parseInt(3, 2)】这次 2 参是 2 , 表示当前 parseInt 要转型一个 2 进制的 3  1 二进制是逢 2 进 1 , 所以这个数超过了二进制的表示范围, 无法正常转换为数值, 也返回 NaN => NaN<br>
map (4, 3) -> 【parseInt(4, 3)】这次 2 参是 3 , 表示当前 parseInt 要转型一个 3 进制的 4  1 二进制是逢 3 进 1 , 所以这个数超过了三进制的表示范围, 无法正常转换为数值, 也返回 NaN => NaN<br>
参考链接 : 
[parseInt - MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt)
[map - MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map);
### 10. 下面代码的输出结果？为什么？
```javascript
var name = '珠峰培训';
function A(x,y){
    var res=x+y;
    console.log(res,this.name);
}
function B(x,y){
    var res=x-y;
    console.log(res,this.name);
}
B.call(A,40,30);
B.call.call.call(A,20,10);
Function.prototype.call(A,60,50);
Function.prototype.call.call.call(A,80,70);
```
解此题须理解 : call 的实现细节<br>
手写call <br>
```javascript
function call(_this, ...args) {

    let flag = !!_this; // 转为布尔类型
    if(!flag) { // 如果 _this 是 false、0、null、undefined、NaN
        _this = window;
    }else { 
        let type = typeof _this;
        if(type !== "object" && type !== "function") { // 如果 _this 是基本类型值
            _this = new Object(_this);    
        }
    }
    let unique = Symbol('zh'); // 唯一索引
	_this[unique] = this; // 设置对应函数属性
	let res = _this[unique](...args); // 执行函数并传参
    delete _this[unique]; // 删除副作用
    return res; // 返回值
}
proto.myCall = call;
})(Function.prototype);	
```
解题思路 : 
- **B.call(A,40,30);**
参数 this 是 A; 函数内部 this 是 B
A[Xxx] = B;  <=>  A\[Xxx\]\(40, 30\) 相当于 B(40, 30);
执行 B 方法(打印) : 10  'A'
- **B.call.call.call(A,20,10);**
`B.call.call`
参数 this 是 A; 函数内部 this 是 B.call.call
A[Xxx] = B.call.call; <=> A\[Xxx\]\(80, 70\) 相当于 B.call.call(40, 30);【此时 B.call.call 内部的 this 已经更新成 A 了 】
`B.call`
参数 this 是 40; 函数内部 this 是 A
new Number(40)[Xxx] = A; <=>  new Number(40)\[Xxx\]\(30\) 相当于 A(30);'
执行 A 方法(打印)  : NaN undefined

- **Function.prototype.call(A,60,50);**  // 跟我没有关系呀(什么也不会输出)

- **Function.prototype.call.call.call(A,80,70);**
`Function.prototype.call.call`
参数 this 是 A; 函数内部 this 是 Function.prototype.call.call
A[Xxx] = Function.prototype.call.call; A\[Xxx\]\(80, 70\) 相当于 Function.prototype.call.call(80, 70);【此时 Function.prototype.call.call 内部的 this 已经更新成 A 了 】
`Function.prototype.call` 
参数 this 是 80; 函数内部 this 是 Function.prototype.call<br>
 new Number(80)[Xxx] = A; <=> new Number(80)\[Xxx\]\(70\) 相当于 A(70);<br>
执行 A 方法(打印)  : NaN undefined

答 : 最后输出为【`下方代码块的注释中标明了答案 :`】 :
```javascript
B.call(A,40,30); // 10, "A"
B.call.call.call(A,20,10); // NaN, undefined
Function.prototype.call(A,60,50);
Function.prototype.call.call.call(A,80,70); // NaN, undefined
```
实际上这道题, 理解了 call 的内部工作机制, 知道 .call.call.call 是从后往前依次执行的就可以了, 比较需要注意的就是, 本题中多次调用 call 的时候传递了参数, 在某个特定的时刻, 参数 this 就是传递的一参, 就导致内部 this 变成了 new Number(arg) .... 到具体方法执行的时候没有给 2 参传递的值, 就是 undefined 再做运算就是 NaN。
### 11. 实现如下需求
```javascript
//=>编写toType方法，实现数据类型检测
function toType( obj ) {
   //完成你的代码
}
console.log(toType(1)); //=>"number"
console.log(toType(NaN)); //=>"number"
console.log(toType([])); //=>"array"
console.log(toType(/^\d+$/)); //=>"regexp"
console.log(toType({})); //=>"object"
```
答 : 代码实现如下  :
```javascript
void(() => {
    function toType( obj ) {
    	//完成你的代码
		let type = Object.prototype.toString.call(obj); // 获取任意类型值的类型
		type = type.substring(type.indexOf(" ") + 1, type.lastIndexOf("]")); // 解析出具体类型
    	return type.toLowerCase(); // 返回已获取类型的小写形式
	}
	console.log(toType(1)); //=>"number"
    console.log(toType(NaN)); //=>"number"
    console.log(toType([])); //=>"array"
    console.log(toType(/^\d+$/)); //=>"regexp"
    console.log(toType({})); //=>"object"
})();
```
### 12. 实现如下需求
```javascript
let utils = (function(){
    /*
     * toArray：转换为数组的方法
     *   @params
     *      不固定数量，不固定类型
     *   @return
     *      [Array] 返回的处理后的新数组
     * by zhufengpeixun on 2020
     */
    function toArray(){
        //=>实现你的代码（多种办法实现）   
    }

    return {
        toArray
    };
})();
let ary = utils.toArray(10,20,30); //=>[10,20,30]
ary = utils.toArray('A',10,20,30); //=>['A',10,20,30]
```
答 : 4 个方法, 代码实现如下 : 
**方法一 : 迭代法**
```javascript
let utils = (function(){
    function toArray(){
        //=>实现你的代码（多种办法实现） 
        let arr = [];  
	    [].forEach.call(arguments, (item, index) => {
			arr.push(item);
		});
		return arr;
    }
    return {
        toArray
    };
})();
let ary = utils.toArray(10,20,30); //=>[10,20,30]
ary = utils.toArray('A',10,20,30); //=>['A',10,20,30]
```
**方法二 : Array.from 法**
```javascript
let utils = (function(){
    function toArray(){
        //=>实现你的代码（多种办法实现） 
		return Array.from(arguments);
    }
    return {
        toArray
    };
})();
let ary = utils.toArray(10,20,30); //=>[10,20,30]
ary = utils.toArray('A',10,20,30); //=>['A',10,20,30]
```
**方法三 : Array.apply 法**
```javascript
let utils = (function(){
    function toArray(){
        //=>实现你的代码（多种办法实现） 
		return Array.apply(null, arguments);
    }
    return {
        toArray
    };
})();
let ary = utils.toArray(10,20,30); //=>[10,20,30]
ary = utils.toArray('A',10,20,30); //=>['A',10,20,30]
```
**方法四 : ES6 扩展运算符**
```javascript
let utils = (function(){
    function toArray(...args){
        //=>实现你的代码（多种办法实现） 
		return args;
    }
    return {
        toArray
    };
})();
let ary = utils.toArray(10,20,30); //=>[10,20,30]
ary = utils.toArray('A',10,20,30); //=>['A',10,20,30]
```
### 13. 完成如下需求
```javascript
~function(){
    function change(){
        //=>实现你的代码
    };
    Function.prototype.change=change;
}();
let obj = {name:'zhufeng'};
function func(x,y){
    this.total=x+y;
    return this;
}
let res = func.change(obj,100,200);
//res => {name:'Alibaba',total:300}
```
答 : 代码实现如下
```javascript
void(() => {
	~function(){
    function change(){
        //=>实现你的代码
		const [_this, ...args] = [...arguments]; // 解构参数 this 与 参数列表
		_this.name = 'Alibaba'; // 修改 name 属性值
		return this.apply(_this, args); // 返回调用结果
    };
    Function.prototype.change=change;
}();
    let obj = {name:'zhufeng'};
    function func(x,y){
        this.total=x+y;
        return this;
    }
    let res = func.change(obj,100,200);
    //res => {name:'Alibaba',total:300}
})();
```
### 14. 完成如下需求
```javascript
~function(){
    //=>bind方法在IE6~8中不兼容，接下来我们自己基于原生JS实现这个方法
	function bind(_this, ...args) {
		
		let flag = 'null undefined'.includes(_this); // 参数 this 为 null 和 undefined 时
		if(flag) {
			_this = window;
		}else { // 参数 this 为 基本类型值时
			let type = typeof _this;
			if(type !== 'object' && type !== 'function') {
				_this = new Object(_this);
			}
		}
		let that = this; // 保存调用函数
		return function(...arr) { // 返回绑定的函数
            
			return that.apply(_this, args.concat(arr)); // 更新 this 指向同时合并 bind 与 调用函数的参数列表
            
		}
	}
    Function.prototype.bind=bind;
}();
var obj = {name:'zhufeng'};
function func(){
    console.log(this,arguments);
    //=>当点击BODY的时候，执行func方法，输出：obj [100,200,MouseEvent事件对象]
}
document.body.onclick = func.bind(obj,100,200);
```
### 15. 对象(数组)的深克隆和浅克隆（头条）
```javascript
//=>浅克隆：只复制对象或者数组的第一级内容
//=>深克隆：克隆后数组的每一级都和原始数组没有关联
//那么请说出，浅克隆都怎么去实现，如何实现深度克隆
let obj = {
    a: 100,
    b: [10, 20, 30],
    c: {
        x: 10
    },
    d: /^\d+$/
};

let arr = [10, [100, 200], {
    x: 10,
    y: 20
}];
```
**浅度克隆 :**
```javascript
// 检测数据类型
function getType(arg) {
	let str = Object.prototype.toString.call(arg);
	return str.substring(str.indexOf(" ") + 1, str.lastIndexOf("]")).toLowerCase();
};

// 浅度克隆
function simpleClone(arg) {
	let res = null;
	let type = getType(arg);
	if(type === "object" || type === "array") {
		res = type === "array" ? [] :  {};
		for(let key in arg) {
			if(arg.hasOwnProperty(key)){
				res[key] = arg[key];
			}
		}
		return res;
	}else {
		return arg;
	}
}
let obj = {
    a: 100,
    b: [10, 20, 30],
    c: {
        x: 10
    },
    d: /^\d+$/
};

let arr = [10, [100, 200], {
    x: 10,
    y: 20
}];
let copy_obj = simpleClone(obj);
let copy_arr = simpleClone(arr);

console.log(obj === copy_obj); // false
console.log(obj.a === copy_obj.a); // true
console.log(obj.b === copy_obj.b); // true
console.log(arr=== copy_arr); // false
console.log(arr[0] === copy_arr[0]); // true
console.log(arr[2] === copy_arr[2]); // true
```
**深度克隆 :**
```javascript
// 检测数据类型
function getType(arg) {
	let str = Object.prototype.toString.call(arg);
	return str.substring(str.indexOf(" ") + 1, str.lastIndexOf("]")).toLowerCase();
};
// 深度克隆
function deepClone(arg) {
	let res = null;
	let type = getType(arg);
	if(type === "object" || type === "array") { // 引用类型值(数组、对象)
		res = type === "array" ? [] :  {};
		for(let key in arg) {
			if(arg.hasOwnProperty(key)){
				res[key] = deepClone(arg[key]); // 递归塑造
			}
		}
		return res;
	}else { // 基本类型值直接返回
		return arg;
	}
}
let obj = {
    a: 100,
    b: [10, 20, 30],
    c: {
        x: 10
    },
    d: /^\d+$/
};

let arr = [10, [100, 200], {
    x: 10,
    y: 20
}];
let copy_obj = deepClone(obj);
let copy_arr = deepClone(arr);

console.log(obj === copy_obj); // false
console.log(obj.a === copy_obj.a); // true
console.log(obj.b === copy_obj.b); // false
console.log(arr=== copy_arr); // false
console.log(arr[0] === copy_arr[0]); // true
console.log(arr[2] === copy_arr[2]); // false
```
### 16. 实现如下需求
```javascript
//=>编写一个ADD函数满足如下需求
add(1);       //1
add(1)(2);    //3
add(1)(2)(3); //6	
add(1)(2,3);  //6
add(1,2)(3);  //6
add(1,2,3);   //6
```
解析 : 
这些函数先单个手动实现一遍【个性中寻找普遍性】 : 
![image.png](https://upload-images.jianshu.io/upload_images/16761151-7c75a7aff50d48fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
挨个实现了一一遍后发现  :
- 我不知道要调用几次, 也即调用次数不固定 : 
- 函数这种连续执行的机制必定是函数返函数 :
- 不论这些参数是以何种方式传进来的, 总能发现一些能够复用的参数, 譬如说上面图中的 arg_1, 也即参数复用。
- 有一个冲突点, 就是 add(1) 和 add(1)(2)和add(1)(2)(3), 如果 add 只返回处理后的 number 类型值的结果而不返回函数的话, add(1) 可以满足但是 add(1)(2) ... 就无法满足。

**要是有办法将这些不管在什么阶段传进来的函数参数一并获取到, 再有个什么钩子函数在特定需要的时刻自行回调来实现累加的逻辑就好了 ?**

到这, 就成功一半了。我们可以使用 柯里化的思想来实现函数的连续执行并且通过给返回的函数重写 valueOf / toString 方法让其在特定的时刻自行回调处理累计逻辑来解决该问题 : 

**也即 :  柯理化思想【连续收集参数】+ valueOf / toString【自行回调时处理累计逻辑】**
先了解什么是函数的柯理化 : 【参考 《JavaScript 高级程序设计第三版》第 22 章 22.1.5 结】<br>
**最终代码如下 :**
答 : 
```javascript
function add(...args) { // 接收参数
	let fn = (...innerArgs) => { args = [...args, ...innerArgs]; return add(...args); }; // 多次调用合并参数并重新调用 add
	fn.valueOf = fn.toString = () => args.reduce((prev, next) => next + prev, 0); // 触发隐式转换的时候进行累加
	return fn; // 调用未结束则继续执行 fn , 如果调用已结束直接返回调用的结果函数
}

/*
add(1);       //1
add(1)(2);    //3
add(1)(2)(3); //6	
add(1)(2,3);  //6
add(1,2)(3);  //6
add(1,2,3);   //6
*/
console.log(add(1,2)(3)); // function 6
console.log(add(1,2)(3) + 0); // 6
console.log(add(1,2)(3) + 1); // 7
```
实际上这样解决最终返回的不是一个基本 number 类型值, 而是 fn, 只不过在使用的时候会隐式的进行数据类型转换, 返回我们重写 toString / valueOf 后的值。
### 17. 实现如下需求
```
/* 
    在函数式编程当中有一个很重要的概念就是函数组合， 实际上就是把处理数据的函数像管道一样连接起来， 然后让数据穿过管道得到最终的结果。 例如：
    const add1 = (x) => x + 1;
    const mul3 = (x) => x * 3;
    const div2 = (x) => x / 2;
    div2(mul3(add1(add1(0)))); //=>3
​
    而这样的写法可读性明显太差了，我们可以构建一个compose函数，它接受任意多个函数作为参数（这些函数都只接受一个参数），然后compose返回的也是一个函数，达到以下的效果：
    const operate = compose(div2, mul3, add1, add1)
    operate(0) //=>相当于div2(mul3(add1(add1(0)))) 
    operate(2) //=>相当于div2(mul3(add1(add1(2))))
​
    简而言之：compose可以把类似于f(g(h(x)))这种写法简化成compose(f, g, h)(x)，请你完成 compose函数的编写 
*/
```
解题思路 : 本题比较简单, 理清思路分钟解决 : 
- 最后需要返回一个函数, 执行函数获取最终结果。
- 一次性可以拿到所有的参数
- 一个函数的调用结果是下一次函数的入参
 如此便可通过对参数列表进行迭代, 实现函数的嵌套调用。
 
 答 : 
**方法一 (借助 for 循环或者其他迭代语句来搞) :**
```javascript
void(() => {
	const add1 = (x) => x + 1;
    const mul3 = (x) => x * 3;
    const div2 = (x) => x / 2;
    function compose(...args) {

        return function(num) {
            let res = num;
            for(let i = 3; i > 0; i-=2) {
                res = args[i-1](args[i](res));
            }
            return res;
        };
    }
    const operate = compose(div2, mul3, add1, add1)
    console.log(operate(0)); // 3
})();
```
**方法二(相同思路使用现成的 reduce 来搞)**
```javascript
void(() => {
	let compose = (...args) => args.reduce((prev, next) => (num) => prev(next(num)));
	const add1 = (x) => x + 1;
	const mul3 = (x) => x * 3;
	const div2 = (x) => x / 2;
	const operate = compose(div2, mul3, add1, add1)
	console.log(operate(0)); // 3
})();
```
### 18. 实现如下需求
```javascript
/* 实现一个$attr(name,value)遍历
 * 属性为name
 * 值为value的元素集合
 * 
 * 例如下面示例:
 */
let ary = $attr('class','box'); //=>获取页面中所有class为box的元素
```
答 : 现获取页面所有节点, 迭代节点匹配入参属性值与节点上的属性值, 一致则添加。
```javascript
const $attr = function $attr(key, val) {
	let res = [];
	[...document.querySelectorAll("*")].forEach((item, index) => {
		new RegExp(`\\b${ val }\\b`).test(item.getAttribute(key)) ? res.push(item) : null ;
	});
	return res;
};
```
测试 : 
```html
<!doctype html>
<html>
 <head>
  <meta charset="UTF-8">
  <title>第 18 题测试</title>
 </head>
 <body>

	<div class="column" name="input" data-image="image/01.png">
		haha
	</div>

	<div class="row column" name="input" data-image="image/01.png">
		heihei
	</div>

	<script>
	const $attr = function $attr(key, val) {
		let res = [];
		[...document.querySelectorAll("*")].forEach((item, index) => {
			new RegExp(`\\b${ val }\\b`).test(item.getAttribute(key)) ? res.push(item) : null ;
		});
		return res;
	};
	console.log($attr('data-image', 'image/01.png'));
	console.log($attr('class', 'column'));
	console.log($attr('name', 'input'));
	</script>
 </body>
</html>
```
![image.png](https://upload-images.jianshu.io/upload_images/16761151-c1c82c03c3aaee95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 19. 如何把一个字符串的大小写取反（大写变小写小写变大写），例如 ’AbC’ 变成 ‘aBc’
答 : 

```javascript
let str = "5sa4dA5a6s4d6E";
str.split("").map((item, index) => item.toUpperCase() === item ? item.toLowerCase() : item.toUpperCase()).join("");
console.log(str); // "5SA4Da5A6S4D6e"
```
### 20. 实现一个字符串匹配算法，从字符串 S 中，查找是否存在字符串 T，若存在返回所在位置，不存在返回-1！（如果不能基于indexOf/includes等内置的方法，你会如何处理呢？）

**基于 for 循环来搞**
```javascript
let str = "天地玄黄, 宇宙洪荒";
void(function(proto) {
	function findIndex(target) {
		let str = [...this].join(""), // 调用字符串
			{ length: strLen } = str, // 调用字符串长度
			{ length: targetLen } = target, // 目标字符串长度
			index = -1; // 默认返回值
		if(targetLen > strLen) return index; // 目标字符串长度大于调用字符串长度
		for(let i = 0; i < strLen - targetLen + 1; i++) { // 字符串匹配 (+1 的原因是, 如果不加 1 会少匹配一次, 或者将前面的条件改为 <= 也行)
			if(str.substr(i, targetLen) === target) {
				index = i;
				break;
			} // 如果找到	
		}
		return index; // 返回匹配结果的索引
	}
	proto.findIndex = findIndex;
})(String.prototype);
console.log(str.findIndex("字符串中不存在的")); // -1
console.log(str.findIndex("宇宙")); // 6
console.log(str.findIndex("超出最大字符数, 不够再加点儿")); // -1
```
**基于动态创建正则表达式来搞**
```javascript
void(function(proto) {
	
	function findIndex(target) {
		let str = [...this].join(""),
			reg = new RegExp(`${ target }`),
			{ length: strLen } = str,
			{ length: targetLen } = target;
		if(targetLen > strLen) return -1;
		let res = reg.exec(str);
		return res === null? -1 : res.index;
	}
	proto.findIndex = findIndex;
})(String.prototype);
let str = "天地玄黄, 宇宙洪荒";
console.log(str.findIndex("字符串中不存在的")); // -1
console.log(str.findIndex("宇宙")); // 6
console.log(str.findIndex("超出最大字符数, 不够再加点儿")); // -1
```
### 21. 实现如下需求
```javascript
//=>toChineseChar函数可以把阿拉伯数字转换为大写的中文数字
("54389").toChineseChar(); //=>”伍肆叁捌玖”
```
答 : 代码实现如下 :
```javascript
void(function(proto) {
	
	function toZHNumber() {
		let arr = ['零', '壹', '贰', '叁', '肆', '伍', '陆', '柒', '捌', '玖'];
		return [...this].map((item, index) => {
			let ele = Number(item);
			return arr[Number.isNaN(ele) ? 0 : ele ];
		}).join("");
	}
	proto.toZHNumber = toZHNumber;
})(String.prototype);
console.log("0123456789".toZHNumber()); // 零壹贰叁肆伍陆柒捌玖
console.log("15263889".toZHNumber()); // 壹伍贰陆叁捌捌玖
console.log("adjkahsdjka".toZHNumber()); // 零零零零零零零零零零零
```
### 22. 实现如下需求
```javascript
let str = 'hello<img src="haha.png" alt="哈哈"/>world';
//=>正确匹配输出 "hello[哈哈]world"
```
答 : 
```javascript
void((prop) => {
	function format() {
		let str = [...this].join("");
		let res = /([a-zA-Z]+)<img .*alt="([^"]+)"\/>([a-zA-Z]+)/.exec(str);
		return `${ res[1] }[${ res[2] }]${ res[3] }`;
	}
	prop.format = format;
})(String.prototype);
let str = 'hello<img src="haha.png" alt="哈哈"/>world';
console.log(str.format()); // hello[哈哈]world
```
### 23. 实现如下需求
```javascript
function fn(str) {
    this.str = str;
}
fn.prototype.format = function () {
    let arg = __1__;
    return this.str.replace(__2__, (a, b) => {
        return arg[b] || '';
    });
};
let t = new fn(`<p>
    <a href="{0}">{1}</a>
    <span>{2}</span>
</p>`);
let HTML = t.format("http://www.alibaba.com", "Alibaba", "welcome");
// console.log(HTML); => "<p><a href="http://www.alibaba.com">Alibaba</a><span>welcome</span></p>"
```
答 : 代码填补如下 : 
```javascript
function fn(str) {
    this.str = str;
}
fn.prototype.format = function () {
    let arg = Array.from(arguments);
    return this.str.replace(/\{(\d+)\}/img, (a, b) => {
        return arg[b] || '';
    });
};
let t = new fn(`<p>
    <a href="{0}">{1}</a>
    <span>{2}</span>
</p>`);
let HTML = t.format("http://www.alibaba.com", "Alibaba", "welcome");
console.log(HTML);//  => "<p><a href="http://www.alibaba.com">Alibaba</a><span>welcome</span></p>"
```
### 24. 计算一个字符串中，字母出现次数最多的字母和出现的次数？（多种方案）
答 : 代码实现如下 : <br>
**方法一(排序) :**
```javascript
void(() => {
	let str = "gf56gf78g8f185w^e^r^djw";
	// 排序(相同的元素排在一起)
    str = [...str].sort((a,b) => a.localeCompare(b)).join("");
    // 将相同的元素按每项放在数组中
    let res = str.match(/([^])\1*/g);
    // 将 res 映射为每项长度组成的数组
    let sizes = res.map((item) => item.length);
    // 求出最大值
    let max = Math.max(...sizes);
    let indexs = [];
    // 找到相同的最大索引
    for(let i = 0; i < sizes.length; i++) {
        if(max === sizes[i]) {
            indexs.push(i);
        }
    }
    let result = [];
	
    // 获取最终结果
    indexs.forEach((item, index) => {

        result.push({
            element: res[item],
            count: max,
        });
    });
    console.log(result);
})();
```
**方案二(去重思想) :**
```javascript
void(function(proto) {
	function find() {
		let str = [...this].join(""),
			obj = {};
		for(let i = 0; i < str.length; i++) {
			if(obj[str[i]]) {
				obj[str[i]] += 1;
				continue;
			}
			obj[str[i]] = 1;
		}
		let keys = Object.keys(obj),
			vals = Object.values(obj),
			max = Math.max(...vals),
			arr = [];
		for(let i = 0; i < vals.length; i++) {
			arr.push({ ele: keys[i], count: vals[i] });
		}
		arr = arr.sort((a, b) => b.count - a.count).filter((item, index) => item.count >= max);
		console.log(arr);
	}
	proto.find = find;
})(String.prototype);
console.log("sa4dsas46a".find());
```
### 25. 完成如下需求
```javascript
//=>编写millimeter实现千分符效果
let str = "2312345638";
str = str.millimeter();
console.log(str); //=>"2,312,345,638"
```
答 : 代码实现如下 : 
```javascript
void(function(proto) {
	function millimeter() {
		let str = [...this].join("");
		return str.replace(/\B(?=(\d{3})+\b)/mg, ',');
	}
	proto.millimeter = millimeter;
})(String.prototype);
let str = "2312345638";
str = str.millimeter();
console.log(str); //=>"2,312,345,638"
```
### 26. 完成如下需求
```javascript
//=>编写formatTime实现时间字符串格式化
let time = "2020-4-8 16:36:8";
time = time.formatTime(); 
console.log(time); //=>"2020年04月08日 16时36分08秒"

time = time.formatTime('{1}-{2} {3}:{4}');
console.log(time); //=>"04-08 16:36"
```
答 : 代码实现如下 : 
```javascript
void(function(proto) {
	function formatTime(template = `{0}年{1}月{2}日 {3}时{4}分{5}秒`) {
		let data = [...this].join("").match(/\d+/g);
		return template.replace(/\{(\d+)\}/g, (_, $1) => {
			
			let item = !data[$1] ? '00' : data[$1];
			item.length < 2 ? item = `0${ item }` : null ;	
			return item;
		});
	}
	proto.formatTime = formatTime;
})(String.prototype);
let time = "2020-4-8 16:36:8";
time = time.formatTime(); 
console.log(time); //=>"2020年04月08日 16时36分08秒"
time = time.formatTime('{1}-{2} {3}:{4}');
console.log(time); //=>"04-08 16:36"
```
### 27. Object.create在项目中经常被用到，但是它不兼容IE低版本浏览器！现在需要我们自己编写一个方法create，实现出类似的效果
```javascript
let obj1 = {a:123};
let obj2 = Object.create(obj1);
//=>返回一个新的空对象，但是该空对象的__proto__是指向了obj1这个对象

function create(proto) {
   //=>完成的你的代码实现Object.create的效果
   function Fun() {};
	Fun.prototype = proto;
	let instance = new Fun();
	Object.defineProperty(instance, 'constructor', {
		enumerable: false,
		value: Object,
	});
	return instance;
}
let obj3=create(obj1);
//=>obj3:{__proto__:obj1}
```
### 28. 已知基于 instanceof 可以实现检测：实例是否属于某个类，现在需要自己编写这样的一个方法，实现出 instanceof 的效果
```javascript
//=>example：要检测的实例
//=>classFunc:要检测的类
function instance_of(example, classFunc) {
    //...
}
let res = instance_of([12,23],Array);
console.log(res); //=>true
```
答 : 代码实现如下 : 
```javascript
function instance_of(example, classFunc) {
	let proto = Object.getPrototypeOf(example);
	if(proto === classFunc.prototype) return true;
	while(proto !== classFunc.prototype) {
		
		if(!!proto) {
			proto = Object.getPrototypeOf(proto);
			if(proto === classFunc.prototype) return true;	
		}else {
			return false;
		} 	
	}
    //...
	return false;
}
let res = instance_of([12,23], Array);
console.log(res); //=>true
```
### 29. 完成如下需求
```javascript
//=>编写convert实现驼峰命名法的转换
let s1 = "get-element-by-id";
s1 = s1.convert(); //=>"getElementById"
```
答 : 代码实现如下 : 
```javascript
void(function(proto) {
	function convert() {
		let str = [...this].join("");
		return str.replace(/\-([a-z])/g, (_, $1) => {
			return $1.toUpperCase();
		});
	}
	proto.convert = convert;
})(String.prototype);
let s1 = "get-element-by-id";
s1 = s1.convert(); //=>"getElementById"
console.log(s1); // "getElementById"
```
### 30. 检测一个值是否为数组都有哪些办法？各自优缺点是啥？
答 : 检测一个值是否为数组可以使用 : `instanceof`、`constructor`、`Object.prototype.toString.call()`
- instanceof : instanceof 是可以检测出 一个值是否是数组类型的, 使用起来也很方便, 但是 instanceOf 是根据原型查找的, 也就是说我们可以人为的将一个非数组类型的变量的原型指向, 使其指向 Array.prototype、或者说拿 Object 检测也会返回 true。所以使用 instanceOf 进行数据类型检测有太大的不确定性。
- constructor : 也可以检测出一个值是否属于数组类型的, 但是 constructor 属性也是可以修改的, 所以 constructor 也有一定的不确定性, 由于其不是按原型链机制来判断的所以相比较 instanceof 来说要好一些。
- Object.prototype.toString.call(Xxx) : 数据类型检测的中级大招, 可以检测出任意类型, 要说优缺点可能就是获取的值需要额外的处理一下。

### 31. 为什么普通 for 循环的性能远远高于 forEach 的性能，请解释其中的原因
答 : 由于 forEach 在迭代的时候每轮都会在堆中开辟一块内存并创建一个回调函数的执行上下文, 这对于性能来说是一个额外的开销。

### 32. 在输入框中如何判断输入的是一个正确的网址
答 : 通过正则表达式匹配 : 代码实现如下 : 
```javascript
<!doctype html>
<html>
 <head>
  <meta charset="UTF-8">
  <title>第 32 题测试</title>
 </head>
 <body>

	<input type="text" id="input">
	<script>
		input.addEventListener('blur', function() {
			let reg = /^((http)s?|ftp):\/\/\w+(\.\w+)*(\/\w+)*(\/)?((\?)(&?([^#=&?]+)=([^#=&?]+))+)?(#[^#=&?]+)?(\/[\w\-#]*)*$/;
			if(reg.test(this.value)) {
				alert("正确地址");
			}else {
				alert("错误地址");
			}
		}, false);
	</script>
 </body>
</html>
```
## 第三部分 : 算法题
### 1. 完成如下需求
```javascript
/*
 * 1.编写一个方法“flatten”，将数组扁平化 （至少三种办法）
 * 2.然后实现“unique”数组去重方法，把数组进行去重 （至少两种办法）
 */
let arr = [
    [1, 2, 2], 
    [3, 4, 5, 5], 
    [6, 7, 8, 9,[11, 12, [12, 13, [14]]]], 
    10
];
ary.flatten().unique().sort((a,b)=>a-b); 
//=>[1, 2, 3, 4, 5, 6, 7, 8, 9....]
```
**方案一(利用 reduce 累加特性通过递归实现数组扁平化 + 判空临时数组实现数组去重) :**
```javascript
void(function(proto) {
    function flatten() { // 数组扁平化
      let arr = this;  
        return arr.reduce((prev, next) => { // 累加调用
            return prev.concat(Array.isArray(next) ? next.flatten() : next ); // 递归拼接
        }, []);  
    }
    
    function unique() { // 数组去重
        let arr = this;
        let ary = []; // 临时数组
        for(let i = 0; i < arr.length; i++) {
            if(!ary.includes(arr[i])) { // 判空临时数组达到去重目的
                ary.push(arr[i]);
            }
        }
        return ary;
    }
    proto.flatten = flatten;
    proto.unique = unique;
})(Array.prototype);
let arr = [
    [1, 2, 2], 
    [3, 4, 5, 5], 
    [6, 7, 8, 9,[11, 12, [12, 13, [14]]]], 
    10
];
console.log(arr.flatten().unique().sort((a,b)=>a-b)); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
```
此方案扁平化思路就是递归调用 flatten 函数, 将当前数组中的非数组类型值 concat 到目标数组中, 这样一层层拼接成一个一维数组。
可以将步骤拆解为 : 
A => [].concat(, 10)

A1 => [].concat(1, 2, 2)

A2 => [].concat(3, 4, 5, 5)

A3 => [].concat(6, 7, 8, 9, )

A3-1 => [].concat(11, 12, )

A3-1-1 => [].concat(12, 13, )

A3-1-1-1 => [].concat(14)

最后合成为 : <br>
[].concat([].concat(1, 2, 2), [].concat(3, 4, 5, 5), [].concat(6, 7, 8, 9, [].concat(11, 12, [].concat(12, 13, [].concat(14)))), 10)

至于本方案使用的去重方式是基于判空空数组来实现的(比较简单就不赘述)。

**方案二(利用 ES6 展开运算符和 while 循环实现数组扁平化 + Set 结构实现数组去重) :**
```javascript
void(function(proto) {
    function flatten() { // 数组扁平化
      let arr = this; 

        while(arr.some((item, index) => Array.isArray(item))) {
            console.log(arr);
            arr = [].concat(...arr);
        }
        return arr;
    }
    
    function unique() { // 数组去重
        let arr = this;        
        return [...new Set(arr)];
    }
    proto.flatten = flatten;
    proto.unique = unique;
})(Array.prototype);
let arr = [
    [1, 2, 2], 
    [3, 4, 5, 5], 
    [6, 7, 8, 9,[11, 12, [12, 13, [14]]]], 
    10
];
console.log(arr.flatten().unique().sort((a,b)=>a-b)); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
```
还是简单说下此方案的数组扁平化的思路, 就是 ES6 的扩展运算符可以将一个二维数组转换为一个一维数组, 利用这个特性加上循环可以实现数组扁平化。说白了就是一级一级的展开。<br>
步骤拆解 : <br>

=> 第一层 : [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9,[11, 12, [12, 13, [14]]]], 10 ]

=> 第二层 : [1, 2, 2, 3, 4, 5, 5, 6, 7, 8, 9, [11, 12,[12, 13, [14]]]]

=> 第三层 : [1, 2, 2, 3, 4, 5, 5, 6, 7, 8, 9, 11, 12,[12, 13, [14]]]

=> 第四层 : [1, 2, 2, 3, 4, 5, 5, 6, 7, 8, 9, 11, 12,12, 13, [14]]

=> 第五层 : [1, 2, 2, 3, 4, 5, 5, 6, 7, 8, 9, 11, 12,12, 13, 14]

**方案三(利用数组的 toString 实现数组扁平化 + Set 结构实现数组去重) :**
```javascript
void(function(proto) {
    function flatten() { // 数组扁平化
      let arr = this; 
      return arr.toString("").split(",").map((item, index) => Number(item));  
    }
    
    function unique() { // 数组去重
        let arr = this;        
        return [...new Set(arr)];
    }
    proto.flatten = flatten;
    proto.unique = unique;
})(Array.prototype);
let arr = [
    [1, 2, 2], 
    [3, 4, 5, 5], 
    [6, 7, 8, 9,[11, 12, [12, 13, [14]]]], 
    10
];
console.log(arr.flatten().unique().sort((a,b)=>a-b)); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
```
这个 toString() 方法可以将任意维度的数组序列化成字符串😀😀神来之笔 !

**方案四(利用数组内置的 flat(deep) 方法(低版本浏览器不支持)实现数组扁平化 + Set 结构实现数组去重) :**
```javascript
void(function(proto) {
    function flatten() { // 数组扁平化
      let arr = this; 
      return arr.flat(arr.length);  
    }
    
    function unique() { // 数组去重
        let arr = this;        
        return [...new Set(arr)];
    }
    proto.flatten = flatten;
    proto.unique = unique;
})(Array.prototype);
let arr = [
    [1, 2, 2], 
    [3, 4, 5, 5], 
    [6, 7, 8, 9,[11, 12, [12, 13, [14]]]], 
    10
];
console.log(arr.flatten().unique().sort((a,b)=>a-b)); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
```

### 2. 完成如下需求
```javascript
/* 
给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数
输入: [1, 2, 3, 4, 5, 6, 7] 和 k = 3
输出: [5, 6, 7, 1, 2, 3, 4]
解释:
向右旋转 1 步: [7, 1, 2, 3, 4, 5, 6]
向右旋转 2 步: [6, 7, 1, 2, 3, 4, 5]
向右旋转 3 步: [5, 6, 7, 1, 2, 3, 4]
​
输入: [-1, -100, 3, 99] 和 k = 2
输出: [3, 99, -1, -100]
解释: 
向右旋转 1 步: [99, -1, -100, 3]
向右旋转 2 步: [3, 99, -1, -100] 
*/
```
答 : 此题我的思路就是, 先矫正索引, 因为索引存在大于参数数组长度的情况, 然后截取指定长度的数组片段添加到数组开头，然后删除结尾多余的元素。
```javascript
function move(arr, position) {
	let _arr = arr.slice();
	while(position > arr.length) { // 处理 position 值大于 arr.length 的情况
		position -= arr.length;
	}
	
	// 移动操作(开头先加, 结尾后减)
	_arr = [..._arr.slice(_arr.length - position, _arr.length), ..._arr];
	_arr.splice(_arr.length - position, position);
	return _arr;
}
console.log(move([99, -1, -100, 3], 5)); // [3, 99, -1, -100]
console.log(move([99, -1, -100, 3], 17)); // [3, 99, -1, -100]
console.log(move([1, 2, 3, 4, 5, 6, 7], 3)); // [5, 6, 7, 1, 2, 3, 4]
```
### 3. 完成如下需求
```javascript
let nums1 = [1, 2, 2, 1];
let nums2 = [2, 2];
//=>给定两个数组，写一个方法来计算它们的交集，输出结果 [2,2]
```
答 : 通过双层 for 循环来解决该问题
```javascript

function intersection(arr, ary) {
	
	let res = [];
	// 克隆一份数组不影响外界
	arr = arr.slice();
	ary = ary.slice();
	// 将长度大的那项放到 for 循环的外层循环【所以当 arr < ary 的时候需要置换一下】
	if(arr.length < ary.length) {
		[arr, ary] = [ary, arr];			
	}
	for(let i = 0; i < arr.length; i++) {
		for(let j = 0; j < ary.length; j++) {
			let index = arr.indexOf(ary[i]); // 找相同元素的索引
			if(index !== -1) { 
				res.push(arr[index]); // 收集交集元素
				arr.splice(index, 1); // 删除判定过的元素防止对下次查找产生干扰
				i--; // 处理数组塌陷
				continue;
			}
		}
	}
	return res;
}

let nums1 = [1, 2, 2, 1];
let nums2 = [2, 2];
console.log(intersection(nums1, nums2)); // [2, 2]
nums1 = [2, 2];
nums2 = [1, 2, 2, 1];
console.log(intersection(nums1, nums2)); // [2, 2]
nums1 = [2, 2];
nums2 = [2, 2];
console.log(intersection(nums1, nums2)); // [2, 2]
nums1 = [1, 2];
nums2 = [2, 2];
console.log(intersection(nums1, nums2)); // [2]
```
### 4. 两个数组和并为一个数组
```javascript
let ary1 = ['A1', 'A2', 'B1', 'B2', 'C1', 'C2', 'D1', 'D2'];
let ary2 = ['A', 'B', 'C', 'D']; 
//=>合并后的数组为：['A1', 'A2', 'A', 'B1', 'B2', 'B', 'C1', 'C2', 'C', 'D1', 'D2', 'D']
```
答 : 利用 String.prototype 上的 localeCompare 方法根据 ASCII 码值排好序, 然后迭代数组换一下 "头" 。
```javascript
let ary1 = ['A1', 'A2', 'B1', 'B2', 'C1', 'C2', 'D1', 'D2'];
let ary2 = ['A', 'B', 'C', 'D']; 
let res = [...ary1, ...ary2].sort((a, b) => a.localeCompare(b)); // 根据 ASCII 码值排序 -> ["A", "A1", "A2", "B", "B1", "B2", "C", "C1", "C2", "D", "D1", "D2"]
for(let i = 0; i < res.length; i += 3) { // 换头(将 A、B、C、D 插入到本组最后一个)
	res.splice(i + 3, 0, res[i]);
	res.splice(i, 1); // 一增一删, 所以不涉及到数组塌陷问题
}
console.log(res); // ["A1", "A2", "A", "B1", "B2", "B", "C1", "C2", "C", "D1", "D2", "D"]
```
### 5. 合并两个有序数组
```javascript
let res = merge([1, 5, 8, 16, 26], [4, 7, 9, 17]);
//=>合并后的数组为：[1, 4, 5, 7, 8, 9, 16, 17, 26]
```
答 : 代码实现如下 : 
```javascript
function merge(arr, ary) {
	return [...arr, ...ary].sort((a, b) => a - b);
}
let res = merge([1, 5, 8, 16, 26], [4, 7, 9, 17]);
console.log(res); // [1, 4, 5, 7, 8, 9, 16, 17, 26]
```
### 6. 完成如下需求
```javascript
/* 
某公司1到12月份的销售额存在一个对象里面
如下： {
    1: 222,
    2: 123,
    5: 888
}，
请把数据处理为如下结构：[222, 123, null, null, 888, null, null, null, null, null, null, null] 
*/
```
答 : 通过 Object.keys 与 Object.values 将键值分离, 然后在迭代语句中通过 indexOf 控制插入位置, 来满足最终的效果:, 代码实现如下 : 
```javascript
let obj = {
    1: 222,
    2: 123,
    5: 888
};

function format(arg) {
	let res = [];
	for(let i = 0; i < 12; i++) {
		let index = Object.keys(arg).map((item) => Number(item)).indexOf(i+1); // 通获取索引
		if(index !== -1) { // 通过比对索引确定位置
			res[i] = Object.values(arg)[index]; // 添加有真实值的元素 
		}else {
			res[i] = null; // 补 null
		}
	}
	return res;
}

console.log(format(obj)); // [222, 123, null, null, 888, null, null, null, null, null, null, null]
```
### 7. 用多种方案实现数组排序，例如：冒泡排序、插入排序、快速排序、希尔排序、选择排序等等，计算各自的时间复杂度
**冒泡排序 :**
```javascript
let arr = [2, 1, 5, 0, 6, 3];
for(let i = 0; i < arr.length - 1; i++) {
	for(let j = 0; j < arr.length - i - 1; j++) {
		
		if(arr[j] > arr[j+1]) [arr[j], arr[j+1]] = [arr[j+1], arr[j]];
	}
}
console.log(arr); // [0, 1, 2, 3, 5, 6]
```
时间复杂度计算 : 针对于此段代码的排序方式而言时间复杂度计算结果为 : `1 + (n-1) + 2(n-1)(n-1)≈2n²-3n+2 => 只保留最高阶项 => n² => O(n²)` 
但是冒泡排序的时间复杂度最好的情况应该是 O(n), 所以需要对代码进行优化 : 
**代码优化后 :**
```javascript
let arr = [2, 1, 5, 0, 6, 3];
let flag;
for(let i = 0; i < arr.length - 1; i++) {
	flag = false;
	for(let j = 0; j < arr.length - i - 1; j++) {
		
		if(arr[j] > arr[j+1]) {
			[arr[j], arr[j+1]] = [arr[j+1], arr[j]];
			flag = true;					
		};
	}
	if(!flag) break;
}
console.log(arr); // [0, 1, 2, 3, 5, 6]
```
所谓最好的情况就是直接传进一个排好序的数组, 优化后的代码就可以体现其最优的 O(n) 的这个特点。
`1 + 1 + 1 + 1 + (n-1) => 只保留最高阶项 => n => O(n)` 

**插入排序 :**
```javascript
let arr = [2, 1, 5, 0, 6, 3];

for(let i = 1; i < arr.length; i++) {
	for(let j = i - 1; j >= 0 && arr[j] > arr[j + 1]; j--) {
		[arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
	}
}
console.log(arr); // [0, 1, 2, 3, 5, 6]
```
时间复杂度计算 : 针对于此段代码的排序方式而言时间复杂度计算结果为 : `1 + n + 2n(n-1)≈2n²-n+1 => 只保留最高阶项 => n² => O(n²)` <br>
**快速排序**
```javascript
function quick_sort(arr, prev, next) {
	let i = prev;
	let j = next;
	let main = arr[prev];
	if(prev >= next) return;

	while(i < j) {
		while(arr[j] >= main && i < j) {
			j--;
		}	
		while(arr[i] <= main && i < j) {
			i++;
		}		
		if(i < j) [arr[i], arr[j]] = [arr[j], arr[i]];
	}
	
	arr[prev] = arr[i];
	arr[i] = main;
	quick_sort(arr, prev, i - 1);
	quick_sort(arr, i + 1, next);	
	return arr;
}
let arr = [2, 1, 5, 0, 6, 3];
console.log(quick_sort(arr, 0, arr.length - 1)); // [0, 1, 2, 3, 5, 6]
```
冒泡排序、插入排序、快速排序, 我的这篇博文有详细说明(所以代码就没有加注释) : [一文扫清【冒泡排序、插入排序、快速排序】的盲点](https://blog.csdn.net/qq_39872652/article/details/104872722)

**希尔排序 :**
就是在插排的基础上将每次需要排序的元素按照 ()Math.floor(数组长度) / 2)拆分成几组, 这几组分别执行插排, 然后周而复始, 把上一次增量的结果再次 Math.floor ... 求出本轮的最小增量, 然后继续分组进行插排, 最后达到排序的目的, 当然当增量小到一定程度的时候就最后直接进行了一把插排, 但是这最后一次仅仅是相当于"微调" 极少的涉及位置操作。

图解 : 
![101.png](https://upload-images.jianshu.io/upload_images/16761151-1298f003693af85e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

```javascript
let arr = [2, 1, 5, 0, 6, 3];
for(let increment = Math.floor(arr.length / 2); increment > 0; increment = Math.floor(increment / 2)) {
	for(let i = increment; i < arr.length; i++) {
        for(let j = i - increment; j >= 0 && arr[j] > arr[j + increment]; j -= increment) {
            [arr[j], arr[j + increment]] = [arr[j + increment], arr[j]];
        }
	}
}
console.log(arr); // [0, 1, 2, 3, 5, 6]
```

**选择排序 :**
答 : 选择排序的核心思路就是, 外层循环每轮都会通过从内层循环得出的最小索引所表示的元素来与上一次排好序的后一个元素交换位置, 这样循环往复, 每次获取的都是本轮中最小的索引并把该索引代表的元素与已经排好序的后一个元素交换位置, 以此来实现最终的排序效果。

这个简单点就不贴图啦 : (数字分析)

start => [2, 1, 5, 0, 6, 3]

minIndex => 3
minItem => 0  
arr => [0, 1, 5, 2, 6, 3]
-- -
minIndex => 1
minItem => 1  
arr => [0, 1, 5, 2, 6, 3]
-- -
minIndex => 3
minItem => 2  
arr => [0, 1, 2, 5, 6, 3]
-- -
minIndex => 5
minItem => 3  
arr => [0, 1, 2, 3, 6, 5]
-- -
minIndex => 5
minItem => 5  
arr => [0, 1, 2, 3, 5, 6]

代码实现如下 : 
```javascript
let arr = [2, 1, 5, 0, 6, 3];
let minIndex = 0;
for(let i = 0; i < arr.length; i++) {
	minIndex = i;
	for(let j = i + 1; j < arr.length; j++) {
		minIndex = arr[j] > arr[minIndex] ? minIndex : j ;
	}
	[arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];
}
console.log(arr); // [0, 1, 2, 3, 5, 6]
```
时间复杂度计算 : 针对于此段代码的排序方式而言时间复杂度计算结果为 : `1 + 1 + 3n + 2n² ≈2n²+3n+2 => 只保留最高阶项 => n² => O(n²)` 

**上述排序算法时间复杂度汇总 :**

| 算法      |     最好情况|   一般情况   |   最差情况   |
| :--------: | :--------:| :------: | :------: |
|冒泡排序    |   O(n)|  O(n²)  |  O(n²)  |
| 选择排序    |   O(n²) |  O(n²) |  O(n²)  |
| 插入排序    |   O(n)|  O(n²)  |  O(n²)  |
| 希尔排序    |   O(nlog(n)) |  O(nlog²(n))  |  O(nlog²(n))  |
| 快速排序    |   O(nlog(n)) |  O(nlog(n))  |  O(n²)  |

### 8. 随机生成一个长度为 10 的整数类型的数组，例如 [2, 10, 3, 4, 5, 11, 10, 11, 20]，将其排列成一个新数组，要求新数组形式如下，例如 [[2, 3, 4, 5], [10, 11], [20]]
答 : 生成随机数组与数组去重部分, 比较简单, 没啥可说的, 主要难点是按阶段分割数组, 本方法是通过先求出所有数据除以 10 后的商的信息(存储起来), 同时生成对应数目的空数组备用,然后通过双层 for 循环来迭代判断 数组除以 10 的商是否与已经存储起来的商的集合中的某一项一致, 如果一致就按当前索引将当前项存储进上面备用的也就是最终的结果数组中。

代码实现如下 : 
```javascript
// 生成随机数组
let arr = [];
for(let i = 0; i < 10; i++) {
	arr.push(Math.round(Math.random() * (Math.random() * (100 - 1 + 1)) + 1));
}
// 随机数组去重
arr = [...new Set(arr)].sort((a, b) => a - b);
let ary = []; // 除以 10 后的商的集合
for(let i = 0; i < arr.length; i++) { // 存储商的数据
	ary.push(Math.floor(arr[i]/10));
}
ary = [...new Set(ary)]; // 商的集合去重
let res = []; // 定义结果数组
for(let i = 0; i < ary.length; i++) { // 初始化 ary.length 个空数组用来存储后面按阶段添加的元素
	res.push([]);
}

for(let i = 0; i < arr.length; i++) { // 按阶段向 res 数组中进行填充
	for(let j = 0; j < ary.length; j++) {
		if(Math.floor(arr[i] / 10) === ary[j]) { // 如果商相等
			res[j].push(arr[i]); // 填充
		}
	}
}
console.log(res);
```
![image.png](https://upload-images.jianshu.io/upload_images/16761151-3226e51895dcc365.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
### 9. 打印出 1 - 10000 之间的所有对称数
答 : 对称数就是说此数值正着读与反着读都是一样的, 利用这个特性可以通过先将当前数值 -> 字符串 -> 数组 -> 反转数组 -> 字符串 -> 数值 , 反转后与反转前对比, 相等就输出。<br>
代码实现如下 :
```javascript
function printSymmetricNum(max) {
	
	for(let i = 1; i < max + 1; i++) {
		
		if(i > 10) {
			let item = +(i).toString().split("").reverse().join("");	
			if(i === item) console.log(item);
		}
	}
}
printSymmetricNum(10000);
```
### 10. 完成如下需求
```javascript
/*
 给定一个数组nums，编写一个函数将所有0移动到数组的末尾，同时保持非零元素的相对顺序
    示例:
    输入: [0,1,0,3,12]
    输出: [1,3,12,0,0]
 必须在原数组上操作，不能拷贝额外的数组。
*/
```
答 : 我的思路是先将数组中的 0 , 全部删掉同时记录删掉的次数, 最后再末尾补零。
代码实现如下 : 
```javascript
function resetArray(arg) {
	
	let index = arg.indexOf(0); // 获取第一次 0 的索引位置
	let count = 0; // 记录被删除的 0 个数量
	while(index !== -1) { // 如果还有 0
		
		arg.splice(index, 1); // 删除对应索引位置的 0
		index = arg.indexOf(0); // 继续更新索引
		count++; // 记录删除 0 的数量
	}
	for(let i = 0; i < count; i++) { // 结尾补 0
		arg.push(0);
	}
}
let arr = [0, 1, 0, 3, 12];
resetArray(arr);
console.log(arr); // [1, 3, 12, 0, 0]
```
### 11. 用 JavaScript 写一个函数，输入 int 型，返回整数逆序后的字符串。如：输入整型 1234，返回字符串“4321”
```javascript
function reverse(arg) {
	let str = `${ arg }`;
	return (str.length < 2) ? str : str.split("").reverse().join("");
}
console.log(reverse(9)); // "9"
console.log(reverse(123456)); // "654321"
```
### 12. 十进制转二进制
答 : 虽然说通过 while 循环除以 2 或者说通过栈结构最后反转也可以拿到最终的二进制数据但是都没有原生的 js 的内置的 toString 方法好, 因为 `toString 方法加了参数本身就是为了做进制转换的`, 你想转化为 2 进制那么你就传递一个 2 即可`所以一句代码即能解决`。

```javascript
Number.prototype.decimal2binary = function decimal2binary() {
	
	return +this.toString(2);
};
console.log((10).decimal2binary()); //=>"1010"
```
### 13. N个人一起玩游戏，围成一圈，从1开始数数，数到M的人自动淘汰；最后剩下的人会取得胜利，问最后剩下的是原来的哪一位？答:
```javascript
function game(n, m) {
   //...
}
console.log(game(8, 5)); //=>就是一共8个人，从第一个人开始数1，第五个人数到5，则退出游戏；接下来从原来第六个开始继续数1，直到下一个数到5的退出游戏...最后剩下的人就是需要的
```
答 : 本题实际上是一道经典的游戏, 他有一个雅致的名字叫做 : `击鼓传花`。实际上就是一个队列首位相连、满足条件 rm 掉一个再次周而复始直至剩余最后一个元素。
本来, 先进先出是队列的准则, 这道题用队列来搞比较符合原则, 但是不想写多余的代码了, 用数组(push 与 shift 方法)也是可以实现类似于 `循环队列` 的效果的。

本题的推导过程 : 

> 12345678 -> 6781234 -> 346781 -> 13467 -> 1346 -> 346 -> 63 -> 3

代码实现如下 : 
```javascript
function game(n, m) {
	
	let res = []; // 结果数组(乘放每轮留下的人 -> 最后只剩一个)
	
	for(let i = 0; i < n; i++) { // 初始化占位数组
		res[i] = i + 1;
	}
	
	let arr = []; // 临时数组(乘放被淘汰的人员)	

	while(res.length > 1) { // 游戏成立的条件(最后剩一个人)
		for(let i = 0; i < m - 1; i++) {
			res.push(res.shift()); // 类似循环队列, 模拟游戏流程, 将 n-1 个添加到末尾开头留下带移除项
		}
		arr.push(res.shift()); // 移除开头项(喊到 5 的人员)
	}
	
	return res[0]; // 输出结果
}
console.log(game(8, 5)); // 3
```

### 14. 所有和为N的连续正数序列
```javascript
/*
 * 输入一个正数N，输出所有和为N的连续正数序列
 * 例如：输入15
 * 结果：[[1,2,3,4,5],[4,5,6],[7,8]]
 */
```
这个算法想出来着实是虎躯一震, 写算法题死机两次, 一次就在这 ......
按理说这道题最简单啊, 不理解为什么会 .... 😅。本方案的解决思路是, 核心就是 : 通过循环保存每次参与累加的元素, 然后累加的结果与阈值判断, 如果符合条件并且等于阈值就将这个阶段参与运算的元素输出到结果数组中, 不论大于还是等于阈值都要清空临时数组与表示 和的那个变量值, 并且将 i 重定位到上一次 >= 阈值开始 +1 的位置继续向后执行同一套操作。

代码实现如下 : 
```javascript
function querySeries(arg) {
	let res = []; // 结果数组
	let sum = 0; // 累加
	let arr = []; // 临时数组(存储一项项相加的元素)
	let prev = 0; // 记忆上一次 (符合条件或者大于条件) 的 i 。
	for(let i = 1; i < arg; i++) {

		sum += i; // 逐项累加
		arr.push(i); // 逐项 push

		if(sum >= arg) { // 当累加结果 >= 阈值
			
			if(sum === arg) { // 当累加结果 === 阈值
				res.push(arr); // 将临时数组中的结果添加到结果数组中
			}
			i = prev + 1; // 将 i 回溯到上一次 (符合条件或者大于条件) 的后一项重新开始
			arr = []; // 清空临时数组
			sum = 0; // 重置 sum
			prev = i; // 记忆上一次 (符合条件或者大于条件) 的 i
		}
	}
	return res;
}

console.log(querySeries(15));
```


### 15. 数组中找出和为N的两个整数
```javascript
/* 
 * 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标
 * nums = [1,6,4,8,7];
 * target = 9
 * => nums[0] + nums[3] = 9
 * => [0,3]
 */
```
本题比较简单, 用一个双层 for 循环就可以解决。但是需要注意的细节点就是, 在双层循环的次数以及起始索引的掌控上, 适当的调整可以提升效率,  核心思想与冒泡排序很像 : 
针对本题而言就是 : 
<pre>
1,6    1,4   1,8   1,7 <br>
6,4    6,8   6,7<br>
4,8    4,7 <br>
8,7<br>
</pre>
这些数列一对一对的相加与阈值比较匹配的就抛出来。<br>
代码实现如下 : 
```javascript
function queryIndex(arg, target) {
	let res = []; // 结果数组
	for(let i = 0; i < arg.length - 1; i++) { // 外层循环控制整每次的当前元素 i
		for(let j = i + 1; j < arg.length; j++){ // 内层循环控制每次的剩余元素 i + 1
			if(target === (arg[i] + arg[j])) { // 符合条件
				let arr = []; // 准备空数组进行存储第一次匹配的一对儿索引
				arr.push(i); // prev Index
				arr.push(j); // next Index
				res.push(arr); // 将当前结果添加到结果数组
			}
		}
	}
	return res;
}
console.log(queryIndex([1,6,4,8,7], 9));
console.log(queryIndex([1,2,3,4,5,6], 8));
```
![image.png](https://upload-images.jianshu.io/upload_images/16761151-92fefaf145af85d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 16. 斐波那契数列
```javascript
/*
 * 实现一个fibonacci [ˌfɪbəˈnɑːtʃi] 函数，实现以下的功能：
 * 斐波那契数列为：[1,1,2,3,5,8,13,21,…]
 * fibonacci(0) -> 1
 * fibonacci(4) -> 5
 */
```
答 : 斐波那契数列就是 an = an-1 + an - 2; (n >= 3); 所以 a1 与 a2 (都等于 1)要拿出来单独处理, 剩下的根据此规则求出指定的 参数对应的数列值即可。
答  : 代码实现如下 : 
```javascript
function fibonacci(max) {
	let prev = 1, // 定义 an - 2
		next = 1, // 定义 an -1
		sum = 0; // 定义 an
	if(max >= 0 && max < 2) return prev; // 处理 a1 与 a2 的情况
	for(let i = 2; i <= max; i++) { //
		// 斐波那契数列(后一项等于前两项之和)
		sum = prev + next;
        [prev, next] = [next, sum];
	}
	return sum;
}
console.log(fibonacci(0)); // 1
console.log(fibonacci(4)); // 5
```
上面不说是 n>= 3 吗 ? 为啥 i 是从 2 开始的 ? 那是因为题意给出了 0 作为参数也有意义, 所以 0 算一位, i 就需要从 2 开始。

================The End======
